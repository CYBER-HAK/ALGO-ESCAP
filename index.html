<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ALGO ESCAPE ‚Äî Dual Pools</title>
<style>
  body {
    font-family: Arial, Helvetica, sans-serif;
    background: #0f0f0f;
    color: #fff;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 { margin-top: 28px; font-size: 2.4rem; text-shadow: 0 0 12px #00ffaa; }
  #story { margin-top: 18px; width: 90%; max-width: 900px; text-align: center; padding: 12px; font-size: 1.05rem; background: #141414; border-radius: 10px; }
  #stats { margin-top: 12px; padding: 8px 16px; background: #222; border-radius: 8px; font-size: 1.05rem; }
  #feed { width: 420px; max-width: 95%; margin-top: 18px; }
  .post { background: #252525; padding: 14px; margin: 12px 0; border-radius: 10px; cursor: pointer; border-left: 5px solid #00ffaa33; transition: transform .18s ease, background .18s ease; }
  .post:hover { transform: scale(1.03); background: #303030; }
  #winScreen, #gameOver { margin-top: 36px; font-size: 1.6rem; display: none; text-align: center; }
  #restartBtn { margin-top: 20px; padding: 10px 18px; font-size: 1.05rem; background: #00ffaa; color: #001; border: none; border-radius: 8px; cursor: pointer; display: none; }
  #restartBtn:hover { background: #00ddaa; }
  .label-pos { border-left-color: #ff7755 !important; } /* visuell unterscheidbar, optional */
  .label-neg { border-left-color: #55dd88 !important; } 
  @media (min-width:800px) { h1 { font-size: 3rem; } #feed { width: 520px; } }
</style>
</head>
<body>
<h1>ALGO ESCAPE ‚Äî Dual Pools</h1>

<div id="story"></div>

<div id="stats">Filterblase: <span id="bubbleValue">80</span>%</div>

<div id="feed" aria-live="polite"></div>

<div id="winScreen">üéâ Du hast den Algorithmus besiegt!</div>
<div id="gameOver">‚ùå Die Filterblase hat dich verschluckt‚Ä¶</div>

<button id="restartBtn">Neu starten</button>

<script>
/* =========================================================
   Einstellungen & Goals
   - Pro Level: 2 Pools (positive = erh√∂ht Bubble, negative = senkt Bubble)
   - Pro Pool: 105 Posts
   - Pro Runde: genau 4 Posts, je Level-Verteilung:
       Level 1: 3 positive, 1 negative
       Level 2: 2 positive, 2 negative
       Level 3: 1 positive, 3 negative
   - Keine Duplikate gleichzeitig
   - Klick entfernt Post dauerhaft aus dem Pool
   - Pools werden beim Levelstart / Restart wiederhergestellt
   - Posts sind kurze, social-media-typische S√§tze, keine Emojis
   ========================================================= */

const POSTS_PER_POOL = 105; // pro Pool (positive/negative) pro Level

let level = 1;
let bubble = 80;

const bubbleValue = document.getElementById('bubbleValue');
const storyBox = document.getElementById('story');
const feed = document.getElementById('feed');
const win = document.getElementById('winScreen');
const gameOver = document.getElementById('gameOver');
const restartBtn = document.getElementById('restartBtn');

/* =========================================================
   Level-Konfiguration: wie viele positive/negative pro Runde
   ========================================================= */
const LEVEL_CONFIG = {
  1: { pos: 3, neg: 1 },
  2: { pos: 2, neg: 2 },
  3: { pos: 1, neg: 3 }
};

/* =========================================================
   Generatoren f√ºr Posts (Templates ohne Zahlen)
   Wir erzeugen programmgesteuert 105 verschiedene Texte pro Pool,
   damit die Datei nicht mit handgeschriebenen 630 Zeilen √ºberladen ist.
   Die Generierung ist determiniert (bei jedem Start gleiche Texte).
   Jeder Post ist ein Objekt: { id, text, effect, type }
   - positive (type='pos'): effect > 0 (erh√∂ht bubble)
   - negative (type='neg'): effect < 0 (senkt bubble)
   ========================================================= */

function makeId(levelNum, poolType, idx) {
  // Erzeugt eine stabile id (kein Nummernlabel in text)
  return `L${levelNum}_${poolType}_${idx}`;
}

function generatePool(levelNum, poolType, count) {
  // poolType: 'pos' oder 'neg'
  const posTemplates = [
    "Unglaublicher Clip, alle reden dar√ºber.",
    "Das f√ºhlt sich so vertraut an, viele werden zustimmen.",
    "Kaum zu glauben, wie klar das hier dargestellt wird.",
    "Dieses Video macht sofort eine starke Meinung sichtbar.",
    "Das ist genau die Art von Inhalt, die man schnell teilt.",
    "Ein kurzer Aufruf, der sofort Reaktionen ausl√∂st.",
    "Das trifft total ins Schwarze bei vielen Leuten.",
    "Solche Ausschnitte lassen kaum Raum f√ºr Zweifel.",
    "Hier wird Stimmung gemacht, und das merkt man sofort.",
    "Ein Beitrag, der klar Stellung bezieht und polarisiert."
  ];

  const negTemplates = [
    "Sachlicher Beitrag mit Quellen und Kontext.",
    "Kurze Erkl√§rung, die hilft, das Thema einzuordnen.",
    "Faktenbasierter Clip ohne gro√üe Dramatisierung.",
    "Neutraler Bericht, der verschiedene Seiten zeigt.",
    "Kurzvideo mit √ºberpr√ºfbaren Hinweisen und Links.",
    "Ein ruhiger Beitrag, der zum Nachdenken einl√§dt.",
    "Objektive Zusammenfassung statt emotionaler Zuspitzung.",
    "Kritische Einordnung, die Mythen entkr√§ftet.",
    "Kurze Analyse statt rei√üerischer Darstellung.",
    "Ein Beitrag, der zur Quellenpr√ºfung anleitet."
  ];

  // W√∂rter/Szenen zur Variation
  const posAdjectives = [
    "viral", "aufregend", "scharf geschnitten", "packend",
    "emotional", "laut", "polarisiert", "suggestiv",
    "dramatisch", "sensationell", "aufgeladen", "provokant",
    "stark formuliert", "kraftvoll", "aufgew√ºhlt"
  ];

  const negAdjectives = [
    "ruhig", "ausgewogen", "sachlich", "klar",
    "informativ", "neutral", "kritisch", "belegt",
    "nachpr√ºfbar", "pr√§zise", "kontextreich", "ausf√ºhrlich",
    "verifiziert", "objektiv", "reflektiert"
  ];

  const pool = [];
  // choose templates and adjectives deterministically to get count different sentences
  for (let i = 0; i < count; i++) {
    const tIndex = i % (poolType === 'pos' ? posTemplates.length : negTemplates.length);
    const aIndex = Math.floor(i / (poolType === 'pos' ? posTemplates.length : negTemplates.length)) % (poolType === 'pos' ? posAdjectives.length : negAdjectives.length);
    const template = poolType === 'pos' ? posTemplates[tIndex] : negTemplates[tIndex];
    const adjective = poolType === 'pos' ? posAdjectives[aIndex] : negAdjectives[aIndex];

    // compose text without adding numeric labels
    let text;
    if (poolType === 'pos') {
      // positive posts sound attention-grabbing / suggestive
      text = template.replace('.', '') + " ‚Äì " + adjective + " inszeniert.";
      // set effects: moderate or strong positive
      const effect = (i % 5 === 0) ? +15 : +10; // some stronger, most +10
      pool.push({ id: makeId(levelNum, poolType, i), text, effect, type: 'pos' });
    } else {
      // negative posts are informative / neutral
      text = template.replace('.', '') + " ‚Äì " + adjective + " pr√§sentiert.";
      // set effects: moderate or strong negative
      const effect = (i % 7 === 0) ? -15 : -10; // some stronger, most -10
      pool.push({ id: makeId(levelNum, poolType, i), text, effect, type: 'neg' });
    }
  }
  return pool;
}

/* =========================================================
   Build levels with two pools each (pos/neg)
   ========================================================= */
const levelPools = {
  1: { pos: generatePool(1, 'pos', POSTS_PER_POOL), neg: generatePool(1, 'neg', POSTS_PER_POOL) },
  2: { pos: generatePool(2, 'pos', POSTS_PER_POOL), neg: generatePool(2, 'neg', POSTS_PER_POOL) },
  3: { pos: generatePool(3, 'pos', POSTS_PER_POOL), neg: generatePool(3, 'neg', POSTS_PER_POOL) }
};

// Keep original copies for reset
const originalPools = deepCopy(levelPools);

/* =========================================================
   Helfer: deep copy
   ========================================================= */
function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); }

/* =========================================================
   START / RENDER / HANDLER
   ========================================================= */

function startLevel() {
  bubble = 80;
  bubbleValue.textContent = bubble;
  storyBox.textContent = level === 1
    ? "Level 1: Leichte Ablenkungen und trendige Clips. Finde die Fakten."
    : level === 2
    ? "Level 2: Emotionen sind st√§rker. Trenne Gef√ºhl und Quelle."
    : "Level 3: Manipulation ist h√§ufiger. Pr√ºfe Quellen sehr genau.";

  // restore pools for the *current* level from originals
  levelPools[1] = deepCopy(originalPools[1]);
  levelPools[2] = deepCopy(originalPools[2]);
  levelPools[3] = deepCopy(originalPools[3]);

  feed.style.display = 'block';
  storyBox.style.display = 'block';
  win.style.display = 'none';
  gameOver.style.display = 'none';
  restartBtn.style.display = 'none';

  renderPosts();
}

function renderPosts() {
  feed.innerHTML = '';

  const cfg = LEVEL_CONFIG[level];
  const neededPos = cfg.pos;
  const neededNeg = cfg.neg;

  // convenience references
  const posPool = levelPools[level].pos;
  const negPool = levelPools[level].neg;

  // if not enough posts to fulfill, we adjust amounts
  const availablePos = posPool.length;
  const availableNeg = negPool.length;

  const takePos = Math.min(neededPos, availablePos);
  const takeNeg = Math.min(neededNeg, availableNeg);

  const selected = []; // hold selected objects, ensure no dup texts across pos/neg

  // helper to pick unique random elements from a pool
  function pickUnique(pool, count) {
    const picked = [];
    if (!pool || pool.length === 0 || count <= 0) return picked;
    // If pool is small relative to count, shuffle copy and take first count
    const copy = pool.slice();
    // Fisher-Yates shuffle for randomness
    for (let i = copy.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    for (let k = 0; k < Math.min(count, copy.length); k++) picked.push(copy[k]);
    return picked;
  }

  // pick positive and negative ensuring no text duplicates
  const chosenPos = pickUnique(posPool, takePos);
  const chosenNeg = pickUnique(negPool, takeNeg);

  // ensure no duplicates across both sets (very unlikely because pools differ, but keep check)
  const texts = new Set();
  chosenPos.forEach(p => { if (!texts.has(p.text)) { selected.push(p); texts.add(p.text); }});
  chosenNeg.forEach(p => { if (!texts.has(p.text)) { selected.push(p); texts.add(p.text); }});

  // If we couldn't reach 4 items because of collisions or low pool sizes, try to fetch more from pools
  // Fill from posPool then negPool as fallback
  function fillFrom(pool, desired) {
    for (let i = 0; i < pool.length && selected.length < desired; i++) {
      const cand = pool[i];
      if (!texts.has(cand.text)) { selected.push(cand); texts.add(cand.text); }
    }
  }
  // target total
  const targetTotal = Math.min(4, availablePos + availableNeg);
  if (selected.length < targetTotal) fillFrom(posPool, targetTotal);
  if (selected.length < targetTotal) fillFrom(negPool, targetTotal);

  // If still less than targetTotal, that's OK; we show as many as possible

  // Render selected items
  selected.forEach(item => {
    const div = document.createElement('div');
    div.className = 'post ' + (item.type === 'pos' ? 'label-pos' : 'label-neg');
    div.textContent = item.text;
    div.dataset.id = item.id;
    div.dataset.type = item.type;
    div.dataset.effect = item.effect;
    div.addEventListener('click', () => handleClick(item.id, item.type, div));
    feed.appendChild(div);
  });

  // If no posts available at all, show a small notice
  if (selected.length === 0) {
    const note = document.createElement('div');
    note.className = 'post';
    note.textContent = 'Keine Posts mehr in den Pools. Starte neu oder wechsle Level.';
    feed.appendChild(note);
  }
}

function handleClick(id, type, div) {
  const effect = Number(div.dataset.effect) || 0;
  bubble = Math.min(100, Math.max(0, bubble + effect));
  bubbleValue.textContent = bubble;

  // remove this post from the appropriate pool permanently
  const pool = levelPools[level][type];
  const idx = pool.findIndex(p => p.id === id);
  if (idx !== -1) pool.splice(idx, 1);

  // remove DOM element
  if (div && div.parentNode) div.parentNode.removeChild(div);

  // check conditions
  if (bubble <= 0) {
    nextLevel();
    return;
  }
  if (bubble >= 100) {
    triggerGameOver();
    return;
  }

  // render new posts to keep 4 (or as many as possible)
  renderPosts();
}

/* Level progression & resets */
function nextLevel() {
  level++;
  if (level > 3) {
    feed.style.display = 'none';
    storyBox.style.display = 'none';
    win.style.display = 'block';
    return;
  }
  // restore all pools when advancing levels (fresh start)
  levelPools[1] = deepCopy(originalPools[1]);
  levelPools[2] = deepCopy(originalPools[2]);
  levelPools[3] = deepCopy(originalPools[3]);
  startLevel();
}

function triggerGameOver() {
  feed.style.display = 'none';
  storyBox.style.display = 'none';
  gameOver.style.display = 'block';
  restartBtn.style.display = 'block';
}

restartBtn.addEventListener('click', () => {
  level = 1;
  levelPools[1] = deepCopy(originalPools[1]);
  levelPools[2] = deepCopy(originalPools[2]);
  levelPools[3] = deepCopy(originalPools[3]);
  gameOver.style.display = 'none';
  restartBtn.style.display = 'none';
  startLevel();
});

/* init */
startLevel();

</script>
</body>
</html>
